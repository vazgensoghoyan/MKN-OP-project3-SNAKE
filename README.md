# Курс основ программирования на МКН СПбГУ
## Проект 3: Игра "Змейка"

В этом проекте требуется реализовать игру "Змейка".

При реализации данного проекта вам предстоит поработать с многопоточностью и синхронизацией при передаче данных из одного потока в другой.

Логика приложения должна быть разделена на два потока. Главный поток и дополнительный который вы запустите самостоятельно.

Первый поток должен считывать события с клавиатуры и передавать их второму потоку. Минимально должно быть 5 событий, на которые
игра будет реагировать: четыре из них это движение вверх, вниз, влево, вправо и пятое выход (по клавише ESC). При выходе, первый поток
должен сигнализировать второму о том, что необходимо завершиться, после чего первый поток должен дождаться завершения второго потока
и после чего выйти. Приложение не должно падать при завершении.

Второй поток должен каждые T миллисекунд просыпаться, обсчитывать новое состояние игры, опираясь на предыдущее состояние и команду
о движении в какую-то сторону, отрисовывать новое состояние на экране и засыпать.

Для синхронизации передачи информации между потоками будет достаточно оператора lock, однако вы так же можете использовать и другие
примитивы синхронизации, такие как: Semaphore (SemaphoreSlim), Mutex, ManualResetEvent и AutoResetEvent. Чтобы потренироваться.

Правила игры просты. На поле из N x M клеток периодически на свободных клетках поля появляется еда (еда не должна заполнять все свободное пространство, подумайте о том,
чтобы ее не становилось больше 10 на всем поле). Змея имея начальный размер в 5 клеток каждые T миллисекунд двигается в направлении куда смотрит ее голова,
и поедая еду растет на одну клетку. Если змея при движении наталкивается на свой хвост или на стену (делать стены или нет, на ваше усмотрение)
игра заканчивается. Как таковых критериев победы у данныой игры нет. Есть только очки которые равны количеству съеденной еды.
В идеале победой можно считать, когда змея заполняет все свободные клетки поля и не может расти дальше.

Данная игра имеет растущую сложность. Начиная с длины 10 и до длины 30 игра постепенно должна ускоряться. Это регулируется интервалом
на который засыпает воторой поток. Давайте сделаем так, до длины 10 T = 600 мс, а при длине 30 и больше T = 300 мс. Между длиной 10 и 30 T линейно уменьшается.
Таким образом змея постепенно будет ускоряться в два раза, что даст игроку меньше времени на реакцию.

Важно, что бы змея двигалась на каждой итерации игры. Если пользователь не нажимал кнопок (WASD или стрелочки, на ваше усмотрение), то змея должна продолжать
двигаться в ту сторону куда двигалась до этого. Змея не может начать двигаться в противоположном направлении. Т.е. если она двигалась влево, то попытка заставить
ее двигаться вправо не должна ничего менять. Хвост змеи проделыавет в точности тот же путь, который прошла ее голова.

Кроме данных рекомендаций можете добавлять в игровой процесс что угодно. Размер поля, наличие стен, наличие оппонета (другой змеи с AI, которая будет поедать еду) и т.д.
все на ваше усмотрение.

Постарайтесь вписать окно приложения в формат 80х25 знакомест.
Попробуйте добавить цвета в оформление интерфейса игры.
Интерфейс приложения не должен скролировался ход от хода. Необходимо полностью перерисовывать игровое поле на том же месте где оно было.
При реализации приложения постарайтесь следовать стилю кодирования, о котором мы говорили на занятии.
Ссылка на документ со стилем будет опубликована в общем чате.

Небольшая подсказка. Чтобы при отрисовке нового состояния игры не возникало морганий, не делайте Console.Clear() на каждой итерации.
Достаточно будет сделать его один раз в начале, чтобы почистить консоль, а на каждой итерации отрисовывать игровое поле поверх предыдущего состояния.

### Начисление баллов

1. [0-4] Оформление и настройка проекта. Ведение комитов в git.
2. [0-4] Удобство использования приложения.
3. [0-8] Полнота и корректность реализации приложения.

### Полезные ссылки:

[1] https://learn.microsoft.com/ru-ru/dotnet/standard/threading/threading-objects-and-features
